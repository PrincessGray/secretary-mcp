# MCP秘书系统架构设计

## 系统架构图

```
+------------------------------------------------------------------------------------------------+
|                                        客户端区域                                                |
+------------------------------------------------------------------------------------------------+
                |                             |                              |
                | 连接1                        | 连接2                         | 连接3
                v                             v                              v
+-------------------------------------------------------------------------------+
|                                   MCP代理服务器                                  |
|                                                                               |
|  +----------------+  +----------------+  +----------------+                    |
|  | 会话1           |  | 会话2           |  | 会话3           |                    |
|  | SessionID: A   |  | SessionID: B   |  | SessionID: C   |                    |
|  |                |  |                |  |                |                    |
|  | Secretary: X   |  | Secretary: Y   |  | Secretary: Z   |                    |
|  +-------+--------+  +-------+--------+  +-------+--------+                    |
|          |                   |                   |                             |
|          v                   v                   v                             |
|  +----------------+  +----------------+  +----------------+                    |
|  | McpClient X    |  | McpClient Y    |  | McpClient Z    |                    |
|  | (连接上游服务器X) |  | (连接上游服务器Y) |  | (连接上游服务器Z) |                    |
|  +----------------+  +----------------+  +----------------+                    |
|                                                                               |
+-------------------------------------------------------------------------------+
                |                             |                              |
                | 上游连接1                     | 上游连接2                      | 上游连接3
                v                             v                              v
+-------------------------------------------------------------------------------+
|                                     上游服务器                                   |
|                                                                               |
|  +----------------+  +----------------+  +----------------+                    |
|  | 上游服务器X      |  | 上游服务器Y      |  | 上游服务器Z      |                    |
|  | 提供任务X的工具   |  | 提供任务Y的工具   |  | 提供任务Z的工具   |                    |
|  +----------------+  +----------------+  +----------------+                    |
+-------------------------------------------------------------------------------+
```

## 关键组件与关系

1. **客户端连接**:
   - 每个客户端通过MCP协议(SSE或STDIO)连接到代理服务器
   - 连接建立后创建一个独立的会话(Session)

2. **会话层(Session)**:
   - 每个会话管理一个客户端连接的生命周期
   - 会话与特定秘书(Secretary)关联
   - 会话间相互隔离，不共享状态

3. **秘书层(Secretary)**:
   - 每个会话只能激活一个秘书
   - 秘书管理多个任务
   - 秘书决定如何路由工具调用

4. **上游客户端**:
   - 每个秘书拥有多个McpClient
   - 每个McpClient连接到不同的上游服务器
   - 上游客户端之间相互隔离

5. **上游服务器**:
   - 提供实际的工具和功能
   - 可以是各种实现(SSE服务器、进程等)
   - 每个服务器独立提供一组特定功能

## 数据流程

### 初始化流程
```
1. 客户端连接到代理服务器
2. 代理服务器创建新会话
3. 客户端激活特定秘书
4. 秘书初始化所需的上游客户端
5. 上游客户端连接到各自的上游服务器
```

### 工具调用流程
```
1. 客户端调用工具 "task.X.status"
2. 代理服务器接收请求，分配到对应会话
3. 会话查找关联的秘书
4. 秘书根据工具名称("task.X.*")决定使用哪个上游客户端
5. 请求转发到正确的上游服务器
6. 上游服务器处理并返回结果
7. 结果通过上游客户端→秘书→会话→代理服务器→客户端返回
```

## 隔离设计

### 会话隔离
- 每个客户端连接有唯一会话ID
- 会话之间不共享状态
- 每个会话只能访问自己关联的秘书

### 秘书隔离
- 一个会话只能激活一个秘书
- 秘书只能访问自己的任务和上游客户端
- 秘书无法访问其他秘书的任务

### 上游服务器隔离
- 每个上游服务器只处理特定任务
- 上游服务器之间不共享信息
- 一个秘书可能需要多个上游连接才能处理所有任务

## 实现要点

### 会话映射
```java
// 会话到秘书的映射
private final ConcurrentHashMap<String, Secretary> sessionSecretaries = new ConcurrentHashMap<>();

// 秘书到上游客户端的映射
private final ConcurrentHashMap<String, Map<String, McpAsyncClient>> secretaryClients = new ConcurrentHashMap<>();
```

### 工具路由
```java
/**
 * 工具调用处理器
 */
private Mono<McpSchema.CallToolResult> handleToolCall(McpServerExchange exchange, Object params) {
    // 获取会话ID
    String sessionId = getCurrentSessionId(exchange);
    
    // 获取关联的秘书
    Secretary secretary = sessionSecretaries.get(sessionId);
    if (secretary == null) {
        return Mono.error(new IllegalStateException("会话未激活秘书"));
    }
    
    // 解析工具名称
    McpSchema.CallToolRequest request = objectMapper.convertValue(params, 
            new TypeReference<McpSchema.CallToolRequest>() {});
    String toolName = request.name();
    
    // 解析任务ID (从工具名称中提取)
    String taskId = extractTaskId(toolName);
    
    // 获取对应的上游客户端
    McpAsyncClient upstreamClient = secretary.getClientForTask(taskId);
    if (upstreamClient == null) {
        return Mono.error(new IllegalStateException("找不到对应任务的上游客户端"));
    }
    
    // 转发调用
    return upstreamClient.callTool(
            new McpSchema.CallToolRequest(
                    getOriginalToolName(toolName),
                    request.arguments()
            ));
}
```

### Exchange代理
```java
/**
 * 创建特定于会话的代理Exchange
 */
private McpAsyncServerExchange createSecretaryExchange(McpServerSession session, String secretaryId) {
    return new McpAsyncServerExchange() {
        @Override
        public Mono<CreateMessageResult> createMessage(CreateMessageRequest request) {
            // 转发到客户端的采样功能
            return session.sendRequest(METHOD_SAMPLING_CREATE_MESSAGE, request, 
                    new TypeReference<CreateMessageResult>() {});
        }
        
        // 实现其他方法...
    };
}
```

这种架构确保了每个会话都有自己独立的秘书和上游服务器连接，提供了强大的隔离性，同时保持了灵活的工具路由能力。
